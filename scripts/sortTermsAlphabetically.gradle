import static groovy.io.FileType.FILES
import java.util.regex.Matcher

class Term {
    String term
    String captionEN
    String captionDE
    String includeFragment

    Term(String term, String captionEN, String captionDE, includeFragment) {
        this.term = term
        this.captionEN = captionEN
        this.captionDE = captionDE
        this.includeFragment = includeFragment
    }
}

task sortTermsAlphabetically(
        description: 'collect terms and create an alphabetically orders structure',
        group: 'isaqb-glossary'
) {
    doLast {
        def terms = createTermsContent()

        sortTermsEN(terms)
        writeTermsStructure(terms, "EN")

        sortTermsDE(terms)
        writeTermsStructure(terms, "DE")
    }

    ext.createTermsContent = {
        def terms = collectTerms()
        List alphabet = ('A'..'Z').collect { it }
        alphabet.each(
                letter -> terms.add(new Term(/==== $letter/, /==== $letter/, /==== $letter/, /=== $letter/))
        )
        return terms
    }

    ext.collectTerms = {
        def termsFolder = new File(projectDir, '/docs/1-terms')
        def terms = []

        termsFolder.traverse(type: FILES) { file ->

            if (file.name ==~ 'term.*[.](ad|adoc|asciidoc)$') {
                println "Learning term from file: " + file.getAbsolutePath()
                def content = file.text

                def term
                def refPath = termsFolder.toPath().relativize( file.toPath() ).toFile()
                def includeFragment = "include::${refPath}[{include_configuration}]";
                def caption_EN
                def caption_DE

                if (content =~ ~/.*(\[#.*\]).*/) {
                    term = Matcher.lastMatcher[0][1]

                }
                def languageCode;
                languageCode = 'EN'
                if (content =~ ~('(?msi)TAG::'+languageCode+'\\[\\].*?(^====.*?$).*?END::'+languageCode+'\\[\\]') ) {
                    caption_EN = Matcher.lastMatcher[0][1].replaceAll('\\s{2,}', ' ')
                }
                languageCode = 'DE'
                if (content =~ ~('(?msi)TAG::'+languageCode+'\\[\\].*?(^====.*?$).*?END::'+languageCode+'\\[\\]') ) {
                    caption_DE = Matcher.lastMatcher[0][1].replaceAll('\\s{2,}', ' ')
                }

                println "TERM $term EN $caption_EN DE $caption_DE $includeFragment"
                terms.add(new Term(term, caption_EN, caption_DE, includeFragment))
            }
        }

        return terms
    }
}

ext.sortTermsEN = { terms ->
    terms.sort { a, b ->
        a.captionEN.compareToIgnoreCase(b.captionEN)
    }
}

ext.sortTermsDE = { terms ->
    terms.sort { a, b ->
        a.captionDE.compareToIgnoreCase(b.captionDE)
    }
}

ext.writeTermsStructure = { terms, languageCode ->
    def termsFolder = new File(projectDir, '/docs/1-terms')
    def outFile = new File(termsFolder, "/0-structure-${languageCode}.adoc")
    println "Structure file: " + outFile.getAbsolutePath()

    outFile.createNewFile()

    final String EMPTYRemark = """// tag::REMARK[]\n// end::REMARK[]\n"""

    outFile.withWriter('UTF-8') { writer ->
        writer.writeLine("// this is autogenerated - please do not modify manually!\n")
        terms.each(
            term -> writer.writeLine(term.includeFragment)
        )
        writer.writeLine(EMPTYRemark)
    }
}